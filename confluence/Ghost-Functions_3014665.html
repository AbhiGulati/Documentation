<!DOCTYPE html>
<html>
    <head>
        <title>Certora Prover Documentation : Ghost Functions</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Certora Prover Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Certora-Prover-Documentation_2916669.html">Certora Prover Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="The-Anatomy-of-a-Specification_238845999.html">The Anatomy of a Specification</a></span>
                            </li>
                                                    <li>
                                <span><a href="Ghosts_41156805.html">Ghosts</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Certora Prover Documentation : Ghost Functions
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> thomas</span>, last modified by <span class='editor'> Nurit Dor</span> on Oct 04, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="GhostFunctions-UninterpretedSorts">Uninterpreted Sorts</h1><p>‌CVT specifications support normal solidity primitives (<code>uint256</code>, <code>address</code> etc.) in addition to some of it's own (for example <code>mathint</code>). These types are <em>interpreted</em> meaning that their values are ascribed some sort of semantics (for example a bitvector of width 256 can be used inside arithmetic operations or comparison operations and has specific semantics associated i.e. <code>2 + 2 = 4</code> or <code>x = y =&gt; z + x = z + y</code> etc.).</p><p>While it can be useful to use interpreted sorts within uninterpreted functions, for reasons we won't get into here, sometimes it is easier to use an <em>uninterpreted sort</em> that doesn't carry around all the &quot;baggage,&quot; so to speak, associated with its interpretation. This is where uninterpreted sorts come in. In CVL an uninterpeted sort is simply declared at the top level of a specification. For example</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Sort MyUninterpSort;
Sort Foo;

rule myRule {    ...</pre>
</div></div><p>‌There are then 3 things we can do with these sorts:</p><ol><li><p>Declare variables of said sort: <code>Foo x</code>.</p></li><li><p>Test equality between two elements of this sort: <code>Foo x; Foo y; assert x == y;</code>;</p></li><li><p>Use these sorts in the signatures of uninterpreted functions: <code>ghost myGhost(uint256 x, Foo f) returns Foo</code>.</p></li></ol><p>Putting these pieces together we might write the following useless, but demonstrative example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Sort Foo;
ghost bar(Foo, Foo) returns Foo;

rule myRule {
  Foo x;
  Foo y;
  Foo z = bar(x, y);
  assert x == y &amp;&amp; y == z;
}</pre>
</div></div><p>‌This will generate an assertion violation. Behind the scenes the solver gets to generate any number of members of the sort <code>Foo</code>. So it can easily generate a counterexample by assigning <code>x</code> to one member and <code>y</code> to the other.</p><h1 id="GhostFunctions-UninterpretedFunctions">Uninterpreted Functions</h1><p>Uninterpreted functions are called <em>uninterpreted</em> because they have <em>no interpretation</em> associated with them. In the example above, it is impossible to say what <code>bar(x, y)</code> <em>means</em>. Uninterpreted functions really only give us a single guarantee:</p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p><code>Any two applications of the same uninterpreted function with the same arguments will return the same value.</code></p></div></div><p>So for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">ghost bar(Foo) returns Foo;

rule shouldSucceed(Foo x, Foo y, Foo z) {
  require bar(x) == y;
  require x == z;    // the solver must choose y for bar(z)
  assert bar(z) == y;
}

rule shouldFail(Foo x, Foo y, Foo z) {
  require bar(x) == y;    // the solver can choose whatever it wants for bar(z)
  assert bar(z) == y;
}</pre>
</div></div><h2 id="GhostFunctions-AxiomsforUninterpretedFunctions‌">Axioms for Uninterpreted Functions‌</h2><p>Sometimes we might want to constrain the behavior of an uninterpreted function in some particular way. In CVL this is achieved by writing <em>axioms</em>. Axioms are simply CVL expressions that the tool will then <em>assume</em> are true about the uninterpreted functions. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">ghost bar(uint256) returns uint256 {
    axiom forall uint256 x. bar(x) &gt; 10;
}</pre>
</div></div><p>‌In any rule that uses <code>bar</code>, no application of <code>bar</code> could ever evaluate to a number less than or equal to 10. While this is not a very interesting axiom, we could imagine expressing more complicated functions, such as a reachability relation.</p><div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Axioms are <strong>dangerous</strong> and should be used <strong>carefully </strong>as they are a potential source of <strong>vacuity bugs</strong>. This can happen in two situations:</p><ol><li><p>The axiom implies <code>false</code></p></li><li><p>Somewhere in the program, we assume something about a ghost function that, when conjuncted with a ghost axiom, implies <code>false</code></p></li></ol></div></div><h2 id="GhostFunctions-InitialAxiomsforUninterpretedFunctions">Initial Axioms for Uninterpreted Functions</h2><p>‌Initial axioms look a lot like axioms but are used for a completely different reason. When writing <em>invariants</em> initial axioms are a way to express the &quot;initial state&quot; of a ghost function. <span class="inline-comment-marker" data-ref="a6e085a7-aae1-48cc-b32c-f79df1f08601">For example:</span></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">ghost sum() returns uint256 {
  init_state axiom sum() == 0;
}</pre>
</div></div><p>This simply states that our sum should start out at zero.</p><p />
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jan 21, 2022 10:00</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
